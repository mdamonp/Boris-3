          ' Added comments September 26, 2015#SETUP    'SUBROUTINE #SETUP               'ABORT ANY MOTION AND TURN OFF AMPLIFIER  AB 1    ' Abort all motion commands  WT 10   ' wait 10 milliseconds  MO      ' turn off motor and toggle amplifier (disable)  WT 10   ' wait 10 milliseconds''DEALLOCATE ALL VARIABLES AND ARRAYS  DA *,*[0]   ' free array and/or memory space'  DM SOFTVER[4]  ' define array with 4 elements  SOFTVER[0]=1   ' initialize SOFTVER[0]   SOFTVER[1]=3   ' initialize SOFTVER[1]   SOFTVER[2]=0   ' initialize SOFTVER[2]   SOFTVER[3]=0   ' initialize SOFTVER[3] ''CLEAR ALL RELEVANT BITS  CB 1;    'BIT 1 IS USED TO DISPLAY WHEN THE PENDANT IS ACTIVE  CB 2;    'BIT 1 IS USED TO DISPLAY WHEN THE TRANSLATOR IS READY  CB 3;    'BIT 1 IS USED TO DISPLAY WHEN THE AMP IS ENABLED''MOTOR PARAMETERS  TRES=81920.0;   'GAIN - ENCODER COUNTS/INCHES  DM ENCDAT[1]    'define array with 1 element   ENCDAT[0]=TRES  'initialize ENCDAT[0]    ACA=10.0*TRES;  'SET DEFAULT ACCELERATION  DCA=1000.0*TRES;'SET DEFAULT DECELERATION''MOTION PARAMETERS    TMAXVEL=@RND[1.0*TRES]; 'MAX VELOCITY IN COUNTS/SEC  THOMVEL=@RND[0.1*TRES]; 'HOMING VELOCITY IN COUNTS/SEC  TJOGVEL=@RND[0.25*TRES];'JOG VELOCITY IN COUNTS/SEC  TPRKPOS=@RND[0.5*TRES]; 'PARK POSITION IN COUNTS  TMINPOS=TPRKPOS;        'MIN POSITION IN COUNTS  TMAXPOS=@RND[5.0*TRES]; 'MAX POSITION IN COUNTS''APPLICATION PARAMETERS  LOAD=-999  MCHSTAT=0;      'MACHINE STATE - SEE Galil State Definitions below  HOMED=0;        'HOME STATUS - 0-NOT HOMED OR 1-HOMED  MAXLOAD=1000;   'MAX LOAD IN POUNDS  LOADGN=1000.0/0.030190;'LOAD GAIN IN POUNDS PER VOLT  PENDST=0;       'PENDANT STATUS - 0-OFF OR 1-ON  TRANRDY=0;      'TRANSLATION READY STATUS - 0-OFF OR 1-ON  TRANIP=0;       'TRANSLATOR IN POSITION - 0-NO OR 1 YES  OFFLOAD=50;     'LOAD LEVEL WHEN SAFE TO MOVE TRANSLATOR OFF OF SUPPORT  NTRANTL=2.5     'INITIALIZE VARIABLE  NTRANTK=5.0     'INITIALIZE VARIABLE  TRANTL=2.5      'INITIALIZE VARIABLE  TRANTK=5.0      'INITIALIZE VARIABLE  APOSTTR=0       'INITIALIZE VARIABLE  AHOME=0         'INITIALIZE VARIABLE''Galil State Definitions ******************'POWER_OFF                              0'POWER_ON_NOT_HOMED                     1'POWER_ON_HOMED                         2'POWER_ON                               3'AT_PARK                                4'MOTION_HALTED                          5'TRANSLATE_COMPLETE                     6'TRANSLATE_COMPLETE_WITH_LIMIT_TRIP     7'SETTING_POWER_STATE                    101'HOMING                                 102'MOVING_TO_POSITION                     103'JOGGING                                104'TRANSLATING                            105'PENDANT_ACTIVE                         201'TRANSLATE_READY                        301'SYSTEM_ERROR                           -1         'POSITION_FOLLOWING_ERROR               -2'******************************************'APPLICATION DATA ARRAYS  DM CMDARG[16];       'COMMAND ARGUMENTS  DM CMDRES[16];       'COMMAND REPLY ARGUMENTS  DM LOCARG[16];       'LOCAL COPY OF COMMAND ARGUMENTS  DM LOCRES[16];       'LOCAL COPY OF COMMAND REPLY ARUGMENTS  DM MCHDAT[3];        'MACHINE STATUS  DM MOTDAT[3];        'MOTOR DATA  DM TRNDAT[4];        'TRANSLATION DATA  DM ERRINFO[3];       'SYSTEM ERROR INFORMATION'  'DEFINE MOTOR DATA ARRAY VALUES  MOTDAT[0]=TMAXVEL  MOTDAT[1]=TMINPOS  MOTDAT[2]=TMAXPOS''SETUP DEFAULT GALIL CONDITIONS =====================================  MT 1       'MOTOR TYPE 1 = SERVOMOTOR  IT 1       'INDEPENDENT TIME CONSTANT VALUE - USED TO SMOOTH MOTION  KP 40      'PROPORTIONAL CONSTANT (PROPORTIONAL GAIN)  KI 2       'INTEGRAL GAIN CONSTANT  KD 2       'DERIVATIVE GAIN CONSTANT  CE 0       'CONFIGURE ENCODER  MT 1       'MOTOR TYPE 1 = SERVOMOTOR  CN -1      'CONFIGURE POLARITY OF LIMIT SWITCHES  DP 0       'DEFINE POSITION - LET PRESENT POSITION BE EQUAL TO ZERO  DE 0       'DUAL (AUXILIARY) ENCODER POSITION  ER -1      'ERROR LIMIT (-1 MEANS DISABLE ERROR OUTPUT)  OE 3       'OFF-ON-ERROR (3 MEANS MOTOR SHUT OFF BY POSITION ERROR, AMPLIFIER ERROR AND LIMIT SWITCH)  TK NTRANTK 'PEAK TORQUE LIMIT  TL NTRANTL 'TORQUE LIMIT  DH 0       'DHCP CLIENT ENABLE (1 MEANS DISABLE BOOT-P AND ENABLE DHCP)  AQ 1,-3;   'SETUP ANALOG INPUT 1 FOR DIFFERENTIAL AND -5 <-> 5 VOLT RANGE  IA 192,168,123,246    'ASSIGN CONTROLLER ITS IP ADDRESS''SAVE PROGRAM AND SETTINGS  BP         'BURN PROGRAM  BV         'BURN VARIABLES & ARRAY  BN         'BURN CERTAIN PARAMETERS TO EEPROM  EN         'END OF SUBROUTINE'#AUTO                         'SUBROUTINE THAT RUNS AUTOMATICALLY UPON POWER UP#RESET                        'START OF #RESET SUBROUTINE  AB 1                        'ABORT MOTION ONLY  MO                          'TURNS OFF ALL MOTORS  ZS 0                        'ZERO SUBROUTINE STACK - CLEAR STACK WHEN FINISHING OR LEAVING SUBROUTINE  INTLOGIC=0                  'SET VARIABLE VALUE  II 0                        'INPUT INTERRUPT (0 DISABLES IT)  ER -1                       'ERROR LIMIT (-1 DISABLES ERROR LIMIT)  BLA=-2147483648             'ASSIGN VALUE TO VARIABLE  FLA=2147483647              'ASSIGN VALUE TO VARIABLE  HX 1;                       'THIS THREAD IS USED FOR MOTION TASKS - HX MEANS HALT EXECUTION  HX 2;                       'THIS THREAD IS USED FOR FILTERING OF LOAD MEASUREMENTS  HX 3;                       'THIS THREAD IS USED FOR BLINKING THE TRANSLATOR READY LED  HX 4                        'HALT THREAD 4  HX 5                        'HALT THREAD 5  HX 6                        'HALT THREAD 6  HX 7                        'HALT THREAD 7  CB 1                        'CLEAR BIT 1 (TURNS OFF DIGITAL OUTPUT 1)  CB 2                        'CLEAR BIT 2 (TURNS OFF DIGITAL OUTPUT 2)  CB 3                        'CLEAR BIT 3 (TURNS OFF DIGITAL OUTPUT 3)  HOMED=0                     'ASSIGN VALUE TO VARIABLE HOMED (0 = NOT HOMED)  LOAD=-999                   'ASSIGN VALUE TO VARIABLE  MCHSTAT=0;                  'POWER OFF  PENDST=0                    'ASSIGN VALUE TO VARIABLE (0 MEANS PENDANT IS DISABLED)  TRANRDY=0                   'ASSIGN VALUE TO VARIABLE (0 MEANS NOT READY FOR TRANSLATION)  TRANIP=0                    'ASSIGN VALUE TO VARIABLE (0 MEANS TRANSLATOR IS NOT IN POSITION)  LASTST=0                    'ASSIGN VALUE TO VARIABLE  CMDPEND=0                   'ASSIGN VALUE TO VARIABLE  CMDSTAT=0                   'ASSIGN VALUE TO VARIABLE  ARGCNT=0                    'ASSIGN VALUE TO VARIABLE  RESCNT=0                    'ASSIGN VALUE TO VARIABLE  CMDID=0                     'ASSIGN VALUE TO VARIABLE (COMMAND ID)  ARGSZ=16                    'ASSIGN VALUE TO VARIABLE  COUNT=0                     'ASSIGN VALUE TO VARIABLE  ERRINFO[0]=0                'ASSIGN VALUE TO VARIABLE  ERRINFO[1]=0                'ASSIGN VALUE TO VARIABLE  ERRINFO[2]=-1               'ASSIGN VALUE TO VARIABLE  MCHDAT[0]=MCHSTAT;          'MACHINE STATE  MCHDAT[1]=0                 'ASSIGN VALUE TO ARRAY ELEMENT  MCHDAT[2]=0                 'ASSIGN VALUE TO ARRAY ELEMENT  IF (AHOME=1)                'IF TRANSLATOR HAS BEEN HOMED ALREADY    SB 3                      'TURN OUTPUT 3 ON    SH                        'SERVO HERE - ENABLES SERVO CONTROL HERE    WT 10                     'WAIT 10 msec    XQ #HOME,1;               'EXECUTE HOME PROGRAM#INIT1                        'BEGINNING OF #INIT1 SUBROUTINE    WT 10    JP #INIT1, _XQ1>0 'JUMP TO FLAG #INIT1 IF _XQ1 > 0 (_XQ1 IS RETURN AFTER THE COMMAND XQ IS ISSUED)    MO                        ' MOTOR OFF    CB 3                      'CLEAR BIT 3 (OUTPUT 3)  ENDIF                       ' END OF IF LOOP  MCHSTAT=0;                  'POWER OFF  INTLOGIC=0                  'ASSIGN VALUE TO VARIABLE  '================================================================================================  'THE NEXT 10 LINES ARE STRANGE. TOM USES BITWISE OPERATIONS TO ASSIGN VALUES TO VARIABLES   'HE USES THE LOGICAL OR SYMBOL | TO PERFORM A BITWISE OPERATION WITH VALUE OF INTLOGIC AND HEX NUMBER $10  'TO REASSIGN THE VALUE OF VARIABLE INTLOGIC. ANOTHER BITWISE OPERATOR IS THE LOGICAL AND &  '================================================================================================  IF (@IN[5]=0)               'IF INPUT 5 IS EQUAL TO 0 (OFF)    INTLOGIC=INTLOGIC | $10   ' BITWISE OR OPERATION    IF (HOMED=1)              'IF THE MOTOR HAS BEEN HOMED      MCHSTAT=3               'REASSIGN VALUE TO VARIABLE    ELSE      MCHSTAT=1               'REASSIGN VALUE TO VARIABLE    ENDIF                     'END OF INNER IF LOOP    SB 3                      ' SET BIT 3 ON (OUTPUT 3)    SH                        ' SERVO HERE  ENDIF                       ' END OF OUTER IF LOOP  IF (@IN[3]=0)               'IF INPUT 3 IS EQUAL TO 0 (OFF)    INTLOGIC=INTLOGIC | $04   'VALUE OF INTLOGIC IS THE RESULT OF A BITWISE OPERATION    IF (MCHSTAT>0)      MCHSTAT=201             'REASSIGN VALUE TO VARIABLE    ENDIF                     'END OF INNER IF LOOP    SB 1                      'SET BIT 1 ON (OUTPUT 1)    PENDST=1                  'PENDANT IS ON  ENDIF                       'END OF OUTER IF LOOP  MCHDAT[0]=MCHSTAT;          'MACHINE STATE  WT 10                       'WAIT 10 msec  XQ #FILTER,2;               'START LOAD FILTER TASK (BEGIN EXECUTION OF PROGRAM #FILTER)  II 1,8,,INTLOGIC            'SPECIFY INTERRUPT ROUTINE#INIT2                        'BEGINNING OF INIT2 SUBROUTINE  CMDARG[COUNT]=0             'RESET VALUE ARRAY MEMBER  CMDRES[COUNT]=0             'RESET VALUE ARRAY MEMBER  LOCARG[COUNT]=0             'RESET VALUE ARRAY MEMBER  LOCRES[COUNT]=0             'RESET VALUE ARRAY MEMBER  COUNT=COUNT+1               'INCREMENT VALUE OF COUNTER  JP #INIT2,COUNT<ARGSZ       'JUMP TO FLAG #INIT2 IF COUNT IS LESS THAN ARGSZ'#CMDPR                        '#CMDPR  FLAG                     MCHDAT[0]=MCHSTAT;          'MACHINE STATE  MCHDAT[1]=_TPA/TRES;        'ABSOLUTE POSITION IN INCHES  MCHDAT[2]=LOAD;             'LOAD CELL VALUE IN POUNDS  IF (CMDPEND=1)              'IF CMDPEND EQUALS 1 REASSIGN VALUES TO CMDID & ARGCNT VARIABLES    CMDID=CMDARG[0]    ARGCNT=CMDARG[1]    IF (ARGCNT>0)             'IF ARGCNT EQUALS 0 REASSIGN VALUES OF COUNT & INDEX VARIABLES      COUNT=0      INDEX=2#CMDPR1                      '#CMDPR1  FLAG      LOCARG[COUNT]=CMDARG[INDEX]      COUNT=COUNT+1      INDEX=INDEX+1      JP #CMDPR1,COUNT<ARGCNT 'JUMP TO FLAG #CMDPR1 IF COUNT IS LESS THAN ARGCNT#CMDPR2                      '#CMDPR2  FLAG      LOCARG[COUNT]=0        'INITIALIZE ARRAY ELEMENT      COUNT=COUNT+1          'INCREASE COUNTER      JP #CMDPR2,COUNT<ARGSZ 'JUMP TO FLAG #CMDPR2 IF COUNT IS LESS THAN ARGSZ    ENDIF                    'END OF IF LOOP    IF (CMDID=1);            'TRANSLATE COMMAND USING FIXED MOVE DISTANCE      JS #FC1                'JUMP TO SUBROUTINE #FC1      JP #CMDPR4             'JUMP TO FLAG #CMDPR4    ENDIF                    'END OF IF LOOP    IF (CMDID=2);            'TRANSLATE COMMAND USING LOAD LIMIT BASED MOVE      JS #FC2                'JUMP TO SUBROUTINE #FC2      JP #CMDPR4             'JUMP TO FLAG #CMDPR4    ENDIF                    'END OF IF LOOP    RESCNT=0                 'RESET VALUE    CMDSTAT=-4               'REASSIGN VALUE TO CMDSTAT    JS #CMDRPY               'JUMP TO SUBROUTINE #CMDRPY    CMDPEND=0                'RESET VARIABLE VALUE#CMDPR4                      '#CMDPR4 FLAG    CMDPEND=2                'REASSIGN VALUE TO CMDPEND  ELSE    WT 10                    ' WAIT 10 msec  ENDIF                      ' END OF IF LOOP  JP #CMDPR                  'JUMP TO #CMDPR FLAG  EN                         ' END OF SUBROUTINE#CMDRPY                      '#CMDPRY FLAG  CMDRES[0]=CMDID            'REASSIGN ARRAY VALUES  CMDRES[1]=CMDSTAT  CMDRES[2]=RESCNT  IF (RESCNT>0)              'IF RESCNT IS GREATER THAN ZERO REASSIGN VALUES OF COUNT AND INDEX VARIABLES    COUNT=0    INDEX=3#CMDRPY1                     '#CMDPRY1 FLAG    CMDRES[INDEX]=LOCRES[COUNT]    INDEX=INDEX+1    COUNT=COUNT+1    JP #CMDRPY1,COUNT<RESCNT 'JUMP TO FLAG #CMDRPY1 IF COUNT IS LESS THAN RESCNT#CMDRPY2                     '#CMDPRY2 FLAG    CMDRES[INDEX]=0          'RESET ARRAY ELEMENT    INDEX=INDEX+1            'INCREASE INDEX VALUE BY 1    JP #CMDRPY2,INDEX<ARGSZ  'JUMP TO FLAG #CMDRPY2 IF INDEX IS LESS THAN ARGSZ  ENDIF                      'END OF IF LOOP  EN                         'END OF SUBROUTINE#CMDERR                      '#CMDERR FLAG  AB1                        'ABORT MOTION ONLY  MO                         'MOTOR OFF  HX 1                       'HALT THREAD 1  HX 2                       'HALT THREAD 2  HX 3                       'HALT THREAD 3  CB 1                       'CLEAR BIT 1  CB 2                       'CLEAR BIT 2   CB 3                       'CLEAR BIT 3  LOAD=-999                  'REASSIGN VALUE TO VARIABLE  ERRINFO[0]=_TC             'REASSIGN VALUES TO ARRAY ELEMENTS  ERRINFO[1]=_ED  ERRINFO[2]=_ED1  MCHSTAT=-1                 'REASSIGN VALUE TO VARIABLE  INTLOGIC=0                 'REASSIGN VALUE TO VARIABLE  II 0                       'DISABLE INPUT INTERRUPT  IF (CMDPEND<>0)            'IF CMDPEND NOT EQUALS 0    RESCNT=0                 'REASSIGN VALUE TO VARIABLE    CMDSTAT=-8               'REASSIGN VALUE TO VARIABLE    JS #CMDRPY               'JUMP TO SUBROUTINE #CMDRPY    CMDPEND=0                'REASSIGN VALUE TO VARIABLE  ENDIF                      'END OF IF LOOP  JP #CMDPR                  'JUMP TO FLAG #CMDPR  EN                         'END OF SUBROUTINE'#FC1                         '#FC1 FLAG  RESCNT=0                   'RESET VARIABLE   IF (_XQ1<>-1)              'IF SYSTEM VARIABLE _XQ1 DOES NOT EQUAL -1    MERRCMD=CMDID            'REASSIGN VARIABLE VALUE    CMDSTAT=-5               'REASSIGN VALUE OF VARIABLE    JS #CMDRPY               'JUMP TO SUBROUTINE #CMDRPY    EN                       'END OF SUBROUTINE  ENDIF                      'END OF IF LOOP  IF (MCHSTAT<2)             'IF MCHSTAT IS GREATER THAN 2 REASSIGN VALUES OF MERRCMD AND CMDRPY    MERRCMD=CMDID    CMDSTAT=-2    JS #CMDRPY               'JUMP TO SUBROUTINE #CMDRPY    EN                       'END OF SUBROUTINE  ENDIF                      'END OF IF LOOP  IF (ARGCNT<>3)             'IF ARGCNT IS NOT EQUAL TO 3 REASSIGN VALUE OF CMDSTAT    CMDSTAT=-7    JS #CMDRPY               'JUMP TO FLAG #CMDRPY    EN                       'END OF SUBROUTINE  ENDIF                      'END OF IF LOOP  TRNDAT[0]=LOCARG[0]*TRES;  'CONVERT TO COUNTS/SEC  TRNDAT[1]=LOCARG[1]*TRES;  'CONVERT TO COUNTS  TRNDAT[2]=LOCARG[2]        'ASSIGN VALUE TO ARRAY ELEMENT  IF ((TRNDAT[0]<1)|(TRNDAT[0]>TMAXVEL)) 'IF TRNDAT[0] IS LESS THAN 1 OR IF IT IS GREATER THAN TMAXPOS REASSIGN VALUE OF CMDSTAT     CMDSTAT=-3    JS #CMDRPY               'JUMP TO SUBROUTINE #CMDRPY    EN                       'END OF SUBROUTINE  ENDIF                      'END OF IF LOOP  IF ((TRNDAT[1]<1)|(TRNDAT[1]>TMAXPOS)) 'IF TRNDAT[1] IS LESS THAN 1 OR IF IT IS GREATER THAN TMAXPOS REASSIGN VALUE OF CMDSTAT     CMDSTAT=-3    JS #CMDRPY                'JUMP TO SUBROUTINE #CMDRPY    EN                        'END OF SUBROUTINE  ENDIF                       'END OF IF LOOP  IF (TRNDAT[2]>MAXLOAD)      'IF ARRAY ELEMENT IS GREATER THAN MAXLOAD REASSIGN VALUE OF CMDSTAT    CMDSTAT=-3    JS #CMDRPY                'JUMP TO SUBROUTINE #CMDRPY    EN                        'END OF SUBROUTINE  ENDIF                       'END OF IF LOOP  ENDPT=_TPA+TRNDAT[1]        'ASSIGN VALUE TO VARIABLE ENDPT  IF (ENDPT>TMAXPOS)    CMDSTAT=-10    JS #CMDRPY                'JUMP TO SUBROUTINE #CMDRPY    EN  ENDIF  LASTST=MCHSTAT  MCHSTAT=105  XQ #TRANSA,1				' EXECUTE TRANSA PROGRAM    WT 10  CMDSTAT=0  JS #CMDRPY                  'JUMP TO SUBROUTINE #CMDRPY  EN'#FC2                          'FLAG #FC2  RESCNT=0                    'RESET VARIABLE  IF (_XQ1<>-1)               'IF SYSTEM VARIABLE _XQ1 DOES NOT EQUAL -1    MERRCMD=CMDID    CMDSTAT=-5    JS #CMDRPY                'JUMP TO SUBROUTINE #CMDRPY    EN  ENDIF  IF (MCHSTAT<2)    MERRCMD=CMDID    CMDSTAT=-2    JS #CMDRPY                'JUMP TO SUBROUTINE #CMDRPY    EN  ENDIF  IF (ARGCNT<>3)    CMDSTAT=-7    JS #CMDRPY                 'JUMP TO SUBROUTINE #CMDRPY    EN  ENDIF  TRNDAT[0]=LOCARG[0]*TRES;'CONVERT TO COUNTS/SEC  TRNDAT[1]=LOCARG[1]*TRES;'CONVERT TO COUNTS  TRNDAT[2]=LOCARG[2]  IF ((TRNDAT[0]<1)|(TRNDAT[0]>TMAXVEL))    CMDSTAT=-3    JS #CMDRPY                'JUMP TO SUBROUTINE #CMDRPY    EN  ENDIF  IF ((TRNDAT[1]<1)|(TRNDAT[1]>TMAXPOS))    CMDSTAT=-3    JS #CMDRPY                'JUMP TO SUBROUTINE #CMDRPY    EN  ENDIF  IF (TRNDAT[2]>MAXLOAD)    CMDSTAT=-3    JS #CMDRPY                'JUMP TO SUBROUTINE #CMDRPY    EN  ENDIF  ENDPT=_TPA+TRNDAT[1]  IF (ENDPT>TMAXPOS)    CMDSTAT=-10    JS #CMDRPY                'JUMP TO SUBROUTINE #CMDRPY    EN  ENDIF  LASTST=MCHSTAT  MCHSTAT=105  XQ #TRANSB,1    'EXECUTE #TRANSB SUBROUTINE  WT 10  CMDSTAT=0  JS #CMDRPY  EN'#HOME             'HOME SUBROUTINE  LASTST=MCHSTAT  'ASSIGN VALUE TO VARIABLE  MCHSTAT=102  TK NTRANTK      'PEAK TORQUE LIMIT  TL NTRANTL      'TORQUE LIMIT  IF (HOMED=1)    'IF ALREADY HOMED    HOMED=0       'RESET VARIABLE    SP TJOGVEL    'ASSIGN SPEED VALUE TO AXIS A    PAA=TPRKPOS   'POSITION ABSOLUTE    BGA           'BEGINS MOTION AXIS A    AMA           'WAIT UNTIL MOTION IS COMPLETED  ENDIF           'END OF IF LOOP  HOMED=0         'RESET VARIABLE  BLA=-2147483648 'REVERSE SOFTWARE LIMIT  FLA=2147483647  'FORWARD SOFTWARE LIMIT  WT 10           'WAIT 10 msec  SPA=THOMVEL     'ASSIGN NEW SPEED VALUE TO AXIS A  FEA             'FIND EDGE COMMAND - MOVE A AXIS UNTIL A TRANSITION IS SEEN ON HOME SWITCH  BGA             'BEGINS MOTION  AMA             '(WAIT UNTIL)AFTER MOVE IS COMPLETED ON AXIS A  WT 10           'WAIT 10 msec  DEA=0           'DUAL ENCODER POSITION ---SUPERFLUOS WE ONLY HAVE 1 ENCODER  WT 10           'WAIT 10 msec  SPA=TJOGVEL     'ASSIGN NEW SPEED VALUE TO AXIS A  PAA=TPRKPOS     'POSITION ABSOLUTE AXIS A  BGA             'BEGIN MOTION  AMA             'WAIT UNTIL MOTION IS COMPLETED  WT 10           'WAIT 10 msec  BLA=TMINPOS     'REVERSE SOFTWARE LIMIT  FLA=TMAXPOS     'FORWARD SOFTWARE LIMIT  HOMED=1         'AXIS A IS HOMED  LASTST=MCHSTAT  'ASSIGN VALUE TO VARIABLE  MCHSTAT=4       'ASSIGN VALUE TO VARIABLE  EN              'END OF SUBROUTINE'#PARK             '#PARK SUBROUTINE  TK NTRANTK      'PEAK TORQUE LIMIT  TL NTRANTL      'TORQUE LIMIT  SPA=TJOGVEL     'ASSIGN SPEED VALUE TO AXIS A  PAA=TPRKPOS     'POSITION ABSOLUTE AXIS A  BGA             'BEGIN MOTION  AMA             'WAIT UNTIL MOTION IS COMPLETED  WT 10           'WAIT 10 msec  MCHSTAT=4       'ASSIGN VALUE TO VARIABLE  EN              'END OF SUBROUTINE'#TRANSA           '#TRANSA SUBROUTINE  TK TRANTK       'PEAK TORQUE LIMIT  TL TRANTL       'TORQUE LIMIT  SPA=TRNDAT[0]   'ASSIGN SPEED VALUE TO AXIS A  PRA=TRNDAT[1]   'ASSIGN RELATIVE POSITION   BGA             'BEGIN MOTION  IF(TRNDAT[2]<=0);'LOAD LIMIT CHECK - <=0 NO LOAD CHECK    AMA            'WAIT UNTIL MOTION IS COMPLETED    WT 10          'WAIT 10 msec    MCHSTAT=6      'ASSIGN VALUE TO VARIABLE    TK NTRANTK     'PEAK TORQUE LIMIT    TL NTRANTL     'TORQUE LIMIT  ELSE#TRANSA1           '#TRANSA1 FLAG    IF (_SCA=0)      IF (LOAD>TRNDAT[2])        STA        'STOP AXIS A        AMA        'WAIT UNTIL MOTION IS COMPLETED        WT 10      'WAIT 10 msec        MCHSTAT=7  'ASSIGN VALUE TO VARIABLE      ELSE        WT 10      'WAIT 10 msec        JP #TRANSA1  'JUMP TO #TRANSA1 FLAG      ENDIF    ELSE      AMA           'WAIT UNTIL MOTION IS COMPLETED      WT 10         'WAIT 10 msec      MCHSTAT=6     'ASSIGN VALUE TO VARIABLE	  REM **************** INSERT SUPPORT ACTUATOR CODE HERE ***************    ENDIF  ENDIF  EN                'END OF SUBROUTINE'#TRANSB             '#TRANSB SUBROUTINE  TK TRANTK         'PEAK TORQUE LIMIT  TL TRANTL         'TORQUE LIMIT  SPA=TRNDAT[0]     'ASSIGN VALUE TO SPEED  PRA=TRNDAT[1]     'ASSIGN VALUE TO RELATIVE POSITION  BGA               'BEGIN MOTION  WT 10             'WAIT 10 msec#TRANSB1            '#TRANSB1 FLAG  IF (_SCA=0)    IF (LOAD>TRNDAT[2])      STA           'STOP AXIS A      AMA           'WAIT FOR COMPLETION OF MOTION      WT 10         'WAIT 10 msec      MCHSTAT=6     'ASSIGN VALUE TO VARIABLE	  REM **************** INSERT SUPPORT ACTUATOR CODE HERE ***************      EN            'END OF SUBROUTINE    ENDIF           'END OF IF LOOP    IF (_TPA>=TRNDAT[1])      STA           'STOP AXIS A      AMA           'WAIT FOR COMPLETION OF MOTION      WT 10         'WAIT 10 msec      MCHSTAT=7     'ASSIGN VALUE TO VARIABLEREM 	  **************** INSERT SUPPORT ACTUATOR CODE HERE ***************      EN            'END OF SUBROUTINE    ENDIF           'END OF IF LOOP    WT 10           'WAIT 10 msec    JP #TRANSB1     'JUMP TO #TRANSB1 FLAG  ENDIF             'END OF OUTER IF LOOP  EN                'END OF SUBROUTINE''==========================================================================='NOTE USE OF BITWISE OPERATIONS USING THE & OPERATOR ON THE SUBROUTINE BELOW' SEE II COMMAND ON gALIL 4123 COMMAND REFERENCE'===========================================================================#ININT              '#ININT SUBROUTINE  WT 10;            'DEBOUNCE, WAIT 10 msec  IF (@IN[1]=0)     'IF INPUT 1 IS LOW    INTTRIG=INTLOGIC & $01  'BITWISE OPERATION    IF (INTTRIG=0)      ZS    ' ZERO (CLEAR) SUBROUTINE STACK      INTLOGIC=INTLOGIC | $01      II 1,8,,INTLOGIC              'INPUT INTERRUPT COMMAND      IF ((PENDST>0)&(TRANIP=0))    'IF PENDST IS GREATER THAN ZERO AND TRANIP EQUALS ZERO         STA                         ' STOP AXIS A        AMA                         ' WAIT UNTIL LAST COMMAND IS COMPLETED        XQ #JOGUP, 1                ' EXECUTE #JOGUP SUBROUTINE       ENDIF      JP #CMDPR                     'JUMP TO #CMDPR FLAG    ENDIF                           'END IF LOOP  ENDIF                             'END OUTER IF LOOP  IF (@IN[1]=1)    INTTRIG=INTLOGIC & $01          'BITWISE AND OPERATION    IF (INTTRIG>0)      ZS                            ' ZERO (CLEAR) SUBROUTINE STACK      INTLOGIC=INTLOGIC & $FE       'BITWISE AND OPERATION      II 1,8,,INTLOGIC              'INPUT INTERRUPT COMMAND      JP #CMDPR                     'JUMP TO #CMDPR FLAG    ENDIF                           'END OF IF LOOP  ENDIF                             'END OF OUTER IF LOOP'  IF (@IN[2]=0)    INTTRIG=INTLOGIC & $02          'BITWISE AND OPERATION    IF (INTTRIG=0)      ZS                            'ZERO (CLEAR) SUBROUTINE STACK      INTLOGIC=INTLOGIC | $02       'BITWISE OR OPERATION      II 1,8,,INTLOGIC              'INPUT INTERRUPT COMMAND      IF (PENDST>0)        STA                         'STOP AXIS A        AMA                         'WAIT TILL MOTION IS COMPLETED        XQ #JOGDWN, 1               'EXETUTE #JOGDWN SUBROUTINE      ENDIF                         'END OF IF LOOP      JP #CMDPR                     'JUMP TO #CMDPR FLAG    ENDIF                           'END OF OUTER IF LOOP  ENDIF                             'END OF OUTER IF LOOP  IF (@IN[2]=1)    INTTRIG=INTLOGIC & $02          'BITWISE AND OPERATION    IF (INTTRIG>0)      ZS                            'CLEAR STACK      INTLOGIC=INTLOGIC & $FD       'BITWISE AND OPERATION      II 1,8,,INTLOGIC              'INPUT INTERRUPT COMMAND      JP #CMDPR                     'JUMP TO #CMDPR FLAG    ENDIF                           'END OF IF LOOP  ENDIF                             'END OF OUTER IF LOOP'  IF (@IN[3]=0)    INTTRIG=INTLOGIC & $04          'BITWISE AND OPERATION    IF (INTTRIG=0)      ZS                            ' ZERO (CLEAR) SUBROUTINE STACK      INTLOGIC=INTLOGIC | $04       'BITWISE OR OPERATION      II 1,8,,INTLOGIC              'INPUT INTERRUPT COMMAND        IF (((MCHSTAT>0) & (MCHSTAT<100)) | (MCHSTAT=301)) 'IF LOOP WITH AND and OR OPERATORS        LASTST=MCHSTAT        MCHSTAT=201        TRANIP=0        TRANRDY=0        SB 1                         'SET BIT 1        CB 2                         'CLEAR BIT 2        PENDST=1        JP #CMDPR                    'JUMP TO #CMDPR FLAG      ENDIF                          'END OF IF LOOP    ENDIF                            'END OF OUTER IF LOOP  ENDIF                              'END OF OUTER OUTER LOOP  IF (@IN[3]=1)    INTTRIG=INTLOGIC & $04           'BITWISE AND OPERATION    IF (INTTRIG>0)      ZS                             'CLEAR STACK      INTLOGIC=INTLOGIC & $FB        'BITWISE AND OPERATION      II 1,8,,INTLOGIC               'INPUT INTERRUPT COMMAND      LASTST=MCHSTAT      IF (HOMED=1)        MCHSTAT=3      ELSE        MCHSTAT=1      ENDIF      STA                            'STOP MOTION      AMA                            'WAIT UNTIL MOTION IS COMPLETED      TRANIP=0      TRANRDY=0      CB 1                           'CLEAR BIT 1      CB 2                           'CLEAR BIT 2      PENDST=0      JP #CMDPR                      'JUMP TO #CMDPR FLAG      ENDIF    ENDIF  ENDIF'  IF (@IN[4]=0)    INTTRIG=INTLOGIC & $08            'BITWISE AND OPERATION    IF (INTTRIG=0)      ZS                              'CLEAR STACK      INTLOGIC=INTLOGIC | $08         'BITWISE OR OPERATION      II 1,8,,INTLOGIC                'INPUT INTERRUPT COMMAND      IF ((MCHSTAT>=3) & (MCHSTAT<100) & (PENDST=0))        IF (LOAD<OFFLOAD)          IF (TRANIP=1)            XQ #POSTRAN,1             'EXECUTE #POSTRAN SUBROUTINE          ELSE            IF (_XQ1=-1)              IF (APOSTTR=1)                XQ #PRETRAN,1         'EXECUTE #PRETRAN SUBROUTINE          ELSE              ELSE                STA                AMA                LASTST=MCHSTAT                MCHSTAT=301                TRANIP=1                TRANRDY=1                SB3              ENDIF            ENDIF          ENDIF          JP #CMDPR                    'JUMP TO #CMDPR FLAG        ENDIF      ENDIF      ENDIF  ENDIF  IF (@IN[4]=1)    INTTRIG=INTLOGIC & $08             'BITWISE AND OPERATION    IF (INTTRIG>0)      ZS                               ' ZERO (CLEAR) SUBROUTINE STACK      INTLOGIC=INTLOGIC & $F7          'BITWISE AND OPERATION      II 1,8,,INTLOGIC                 'INPUT INTERRUPT COMMAND      JP #CMDPR    ENDIF  ENDIF'  IF (@IN[5]=0)    INTTRIG=INTLOGIC & $10             'BITWISE AND OPERATION    IF (INTTRIG=0)      ZS                               ' ZERO (CLEAR) SUBROUTINE STACK      INTLOGIC=INTLOGIC | $10          'BITWISE OR OPERATION      II 1,8,,INTLOGIC      IF (MCHSTAT=0)        LASTST=MCHSTAT        IF (HOMED=1)          MCHSTAT=3        ELSE          MCHSTAT=1        ENDIF        SB 3        CB 2        SH      ENDIF      JP #CMDPR                        'JUMP TO #CMDPR FLAG    ENDIF  ENDIF  IF (@IN[5]=1)    INTTRIG=INTLOGIC & $10             'BITWISE AND OPERATION    IF (INTTRIG>0)      ZS                               ' ZERO (CLEAR) SUBROUTINE STACK      INTLOGIC=INTLOGIC & $EF          'BITWISE AND OPERATION      II 1,8,,INTLOGIC                 'INPUT INTERRUPT COMMAND      LASTST=MCHSTAT      MCHSTAT=0      CB3                              'CLEAR BIT 3      STA                              'STOP MOTION      AMA                              'WAIT UNTIL COMPLETED      MO                               'MOTOR OFF      JP #CMDPR                        'JUMP TO #CMDPR FLAG    ENDIF  ENDIF'  IF (@IN[6]=0)    INTTRIG=INTLOGIC & $20             'BITWISE AND OPERATION    IF (INTTRIG=0)      ZS                               ' ZERO (CLEAR) SUBROUTINE STACK      INTLOGIC=INTLOGIC | $20      II 1,8,,INTLOGIC                 'INPUT INTERRUPT COMMAND      IF ((MCHSTAT=103) | (MCHSTAT=104))        HX1        STA        AMA        LASTST=MCHSTAT        MCHSTAT=301        TRANIP=1        TRANRDY=1        HX3        SB3      ENDIF      JP #CMDPR                        'JUMP TO #CMDPR FLAG    ENDIF  ENDIF  IF (@IN[6]=1)    INTTRIG=INTLOGIC & $20             'BITWISE AND OPERATION    IF (INTTRIG>0)      ZS                               ' ZERO (CLEAR) SUBROUTINE STACK      INTLOGIC=INTLOGIC & $DF          'BITWISE AND OPERATION      II 1,8,,INTLOGIC                 'INPUT INTERRUPT COMMAND      TRANIP=0      IF (MCHSTAT=301)        LASTST=MCHSTAT        MCHSTAT=3        CB2        TRANIP=0        TRANRDY=0      ENDIF      JP #CMDPR    ENDIF  ENDIF'  IF (@IN[7]=0)    INTTRIG=INTLOGIC & $40    IF (INTTRIG=0)      ZS                                 ' ZERO (CLEAR) SUBROUTINE STACK      INTLOGIC=INTLOGIC | $40      II 1,8,,INTLOGIC                   'INPUT INTERRUPT COMMAND      IF (MCHSTAT>0)        HX1        STA        AMA        TRANRDY=0        TRANIP=0        CB 2        LASTST=MCHSTAT        IF (HOMED=1)          MCHSTAT=3        ELSE          MCHSTAT=1        ENDIF        JP #CMDPR                        'JUMP TO #CMDPR FLAG      ENDIF    ENDIF  ENDIF  IF (@IN[7]=1)    INTTRIG=INTLOGIC & $40    IF (INTTRIG>0)      ZS                            ' ZERO (CLEAR) SUBROUTINE STACK      INTLOGIC=INTLOGIC & $BF      II 1,8,,INTLOGIC              'INPUT INTERRUPT COMMAND      JP #CMDPR    ENDIF  ENDIF'  IF (@IN[8]=0)    INTTRIG=INTLOGIC & $80    IF (INTTRIG=0)      ZS  ' ZERO (CLEAR) SUBROUTINE STACK      INTLOGIC=INTLOGIC | $80      II 1,8,,INTLOGIC      IF ((HOMED=0) & (MCHSTAT=1))        STA        AMA        XQ #HOME, 1      ENDIF      JP #CMDPR    ENDIF  ENDIF  IF (@IN[8]=1)    INTTRIG=INTLOGIC & $80    IF (INTTRIG>0)      ZS   ' ZERO (CLEAR) SUBROUTINE STACK      INTLOGIC=INTLOGIC & $7F      II 1,8,,INTLOGIC      JP #CMDPR    ENDIF  ENDIF'  RI 1'#JOGUP                   '#JOGUP SUBROUTINE  LASTST=MCHSTAT  MCHSTAT=104  TK NTRANTK  TL NTRANTL  JGA=TJOGVEL  BGA  AI 1                   'WAIT UNTIL INPUT CHANGES STATE  STA                    ' STOP MOTION  AMA                    'WAIT UNTIL DONE  LASTST=MCHSTAT  MCHSTAT=201  EN'#JOGDWN  LASTST=MCHSTAT  MCHSTAT=104  TK NTRANTK  TL NTRANTL  JGA=-TJOGVEL  BGA  AI 2  STA  AMA  LASTST=MCHSTAT  MCHSTAT=201  EN'#PRETRAN  LASTST=MCHSTAT  MCHSTAT=103  XQ #BLINK, 3  TK NTRANTK  TL NTRANTL  PAA=TMAXPOS  SPA=TJOGVEL  BGA  AMA  LASTST=MCHSTAT  MCHSTAT=-4  TRANIP=0  TRANRDY=0  HX3  CB2  IF (CMDPEND<>0)    RESCNT=0    CMDSTAT=-8    JS #CMDRPY    CMDPEND=0  ENDIF  JP #CMDPR  EN'#POSTRAN  LASTST=MCHSTAT  MCHSTAT=104  XQ #BLINK, 3  TK NTRANTK  TL NTRANTL  PAA=TPRKPOS  SPA=TJOGVEL  BGA  AMA  TRANIP=0  TRANRDY=0  LASTST=MCHSTAT  MCHSTAT=4  HX3  CB2  EN'#POSERR  AB1  MO  TK NTRANTK  TL NTRANTL  INTLOGIC=0  II 0  HX 1  CB 1  CB 2  CB 3  LASTST=MCHSTAT  MCHSTAT=-2  IF (CMDPEND<>0)    RESCNT=0    CMDSTAT=-8    JS #CMDRPY    CMDPEND=0  ENDIF  JP #CMDPR  EN'#FILTER'Single poll filter'k1+k2 = 1 - use division with m div 2^n ratio'FLEVEL 0<->63 WITH FLEVEL=0 - NO FILTERING OR FLEVEL=63 MAX FILTERING  FLEVEL=60  k1=(64-FLEVEL)/64  k2=FLEVEL/64  AT0;'set initial time reference  AN1=*@AN[1];'set filter seed  LOAD=@ABS[AN1*LOADGN]  AT-10,0#FILTER1  AN1=(k1*@AN[1])+(k2*AN1) 'PERFORM AVERAGING CALCULATION  LOAD=@ABS[AN1*LOADGN]  'CALCULATE AND ASSIGN VALUE TO LOAD  AT-10,0  JP#FILTER1 'JUMP TO #FILTER 1 SUBROUTINE  EN'#BLINK  IF (@OUT[3]=0) 'IF OUTPUT 3 IS LOW (0)    SB 2  'SET BIT 2 HIGH (TURN OUTPUT 2 ON)  ELSE    CB 2  'CLEAR OUTPUT 2  ENDIF  WT250  'WAIT 250 msec  JP #BLINK 'JUMP TO #BLINK SUBROUTINE  EN